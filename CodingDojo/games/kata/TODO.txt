Kata
+   Пофиксить Readme.MD
+   Пофиксить kata.html
+   Чтобы приходила вся история
+   Протестили на клиенте - реализовали парсинг ответов
+   Сделали хорошее форматирование
+   Хистори надо как-то ограничивать, потому что очень много инфы приходит и это может лагать сетку
+       Может хистори не передавать клиенту?
+       Мы ему передаем только последнюю транзакцию
+   Реализовать набор задач
+       Если у нас первая задача решена, тогда включаются вопросы из второй
+           Сделать переключение
+           Покрыть тестами все что накодили (проверить каверадж)
-       На админке можно менять порядок задач местами для играющих
+   Исправить KataPerformanceTest
-   Реализация очков
+        За каждый пройденный подряд зеленый тест +1
+        За каждый решенный алгоритм по умолчанию давать очкки равные 100
x            Давать очков столько, сколько у алгоритма complexity
x            Этот бал по каждому тесту можно выставлять на админке
+   Описание дескрипшена уровня выдавать клиенту в input JSON
+   Реализовать ApofigAI чтобы он по всем классам бегал и давал правильные ответы
+   Сделать, чтобы в хистори было видно только последний ответ, когда игра закончилась
-   Разобраться, почему тесты валятся в clean install те что с аппрувалсом, пока я их закомментил
-   Написать много новых алгоритмов!
+   Воркфлоу игры связанный со временем
+       Дать команду (от игрока) запуска таймера (получения следующего алгоритма)
+       Выдавать очков за пройденный алгоритм так много, как мало времени было на него потрачено
+           Поменять все сложности алгоритмов
x            Алгоритм 1
x                Максимальное количестко очков = complexity алгоритма
x                    300
x                Количество очков не может быть меньше 30 % стоимости задачи
x                    >60m
x                    30% от complexity
x                Эталон решения любого алгоритма
x                    <= 1m
x                    За него получаем максимальное количество очков
x                Формула продсчета очков
x                    Время =
x                        (если Время < 1 минута) то 1 минута
x                        (если Время > 60 минут) то 60 минут
x                        иначе Время
x                    Пропорция
x                        y-Время > x-Очки
x                            a=1 > complexity очков
x                            Время > x очков
x                            b=60 > c=30% от complexity очков
x                    (y-a)/(b-a)=(x-complexity)/(c*complexity/100-complexity)
x                    (c*complexity/100-complexity)*(y-a)/(b-a)=x-complexity
x                    complexity*(c/100-1)*(y-a)/(b-a)=x-complexity
x                    complexity + complexity*(c/100-1)*(y-a) / (b-a) = x
x                    x = complexity + complexity*(c/100-1)*(y-a) / (b-a)
x                Играют 6 ребят
x                    <= 1 минуту  = 300 + 300*(30/100-1)*(1-1) / (60-1) = 300
x                    5 минут  = 300 + 300*(30/100-1)*(5-1) / (60-1) = 285
x                    10 минут
x                    15 минут
x                    23 минуты
x                    24 минуты
x                    24 минуты = 300 + 300*(30/100-1)*(24-1) / (60-1) = 218
x                    59 минут = 300 + 300*(30/100-1)*(59-1) / (60-1) = 93
+            Алгоритм 2
+                С разными по сложности алгоритмами
+                    За сколько идеально решить эту задачу - это и есть complexity
+                    При этом максимальный рубеж
+                        Это B=3x времени
+                        Все, что больше - оно считается как C=30% от комплексити
+                Максимальное количестко очков
+                    complexity алгоритма
+                        - если время больше или рано идеальному времени
+                    complexity алгоритма * то, в сколько раз превысили это время
+                        = complexity/(1-time/complexity) ???
+                        - если время меньше идеального
+                Количество очков не может быть меньше 30 % стоимости задачи
+                    >3x complexity минут
+                    30% от complexity
+                Эталон решения любого алгоритма
+                    <= Complexity m
+                    y,Время > x,Очки
+                        complexity > complexity очков
+                        y Время > x очков
+                        B=3*complexity > C=30% от complexity очков
+                    (y-y1)/(y2-y1)=(x-x1)/(x2-x1)
+                    (y1-y2)*x+(x2-x1)*y+(x1*y2-x2*y1)=0
+                    x=-((x2-x1)*y+(x1*y2-x2*y1))/(y1-y2)
+                    x=((x2-x1)*y+(x1*y2-x2*y1))/(y2-y1)
+                    x1=y1=co
+                    y2=B*co
+                    x2=C*co/100
+
+                    x=((C*co/100-co)*y + (co*B*co-C*co/100*co))/(B*co-co)
+                    x=(co*(C/100-1)*y + co^2*(B-C/100))/(B-1)*co
+                    x=((C/100-1)*y + co*(B-C/100))/(B-1)
+                Опционально можно домножать результат на A чтобы небыло дробных частей
+                Играют N ребят
+                    x = ((0.3-1)*y + co*(3-0.3))/(3-1)
+                    10 минут
+                        1 минуту  = ((0,3-1)*1 + 10*(3-0,3))/(3-1)   = 13,15
+                        5 минут   = ((0,3-1)*5 + 10*(3-0,3))/(3-1)   = 11,75
+                        10 минут  = ((0,3-1)*10 + 10*(3-0,3))/(3-1)  = 10
+                        15 минут  = ((0,3-1)*15 + 10*(3-0,3))/(3-1)  = 8,25
+                        20 минут  = ((0,3-1)*20 + 10*(3-0,3))/(3-1)  = 6,5
+                        30 минут  = ((0,3-1)*30 + 10*(3-0,3))/(3-1)  = 3
+                        60 минут  < complexity*B = same as f(complexity*B)
+                        100 минут < complexity*B = same as f(complexity*B)
+                    30 минут
+                        1 минуту  = ((0,3-1)*1 + 30*(3-0,3))/(3-1) = 40,15
+                        5 минут   = ((0,3-1)*5 + 30*(3-0,3))/(3-1) = 38,75
+                        10 минут  = ((0,3-1)*10 + 30*(3-0,3))/(3-1) = 37
+                        15 минут  = ((0,3-1)*15 + 30*(3-0,3))/(3-1) = 35,25
+                        20 минут  = ((0,3-1)*20 + 30*(3-0,3))/(3-1) = 33,5
+                        30 минут  = ((0,3-1)*30 + 30*(3-0,3))/(3-1) = 30
+                        60 минут  = ((0,3-1)*60 + 30*(3-0,3))/(3-1) = 19,5
+                        90 минут  = ((0,3-1)*90 + 30*(3-0,3))/(3-1) = 9
+                        100 минут < complexity*B = same as f(complexity*B)
+                        120 минут < complexity*B = same as f(complexity*B)
+                        200 минут < complexity*B = same as f(complexity*B)
+            Алгоритм 3 - подбодряшка
+                Мы даем не более D% от Capacity на все тесты - это наш баджет
+                    Порядка 10%
+                За кажыдй тест = A * (D/(100*TestCount))
+       Дать команду (от игрока) скипнуть этот алгоритм (не получать за него очки)
+   Подписали авторство алгоритмов
-   Фидбеки после тестирования
+       Отключить просмотр других бордов (алгоритмов) у других ребят
+       Скинуть номер уровня в JSON для клиента
+       Убрать название класса из описания игры, чтобы нельзя было загуглить решение
+       Не понятно описание powerDigitSum алгритма - не ясно что надо возводить в степень
-       Деление в столбик 
+           Сделать самой последней
-           Убрать подчет периода (сделать копию алгоритма более легкого)
-           Есть оишбка в тесте 111 / 110 = 1.00(90) а надо 1.0(09)  
-           В кейсе, который 0ю857694... 66666666 777277777 у меня просиходит округление ответа, который приходит клиенту
+       Реализовать http://nazva.net/735
+       Реализовать http://nazva.net/78
-       Реализовать http://nazva.net/668
!       Добавить JS и .Net клиентов
+       Сделать первый алгоритм, который типа hello world чтобы на нем все настроились
-           и не давать запускать дальше алгоритмы, пока Админ не скажет на сервере, что пора
-   Information:java: Multiple encodings set for module chunk kata-engine "windows-1251" will be used by compiler
+   Сделать так, чтобы на UI приходил номер уровня не с 1 а с 0, как клиенту, потому что 0й уровень - это HelloWorld
+   Сделать логгирование того, кто как играл и когда заканчивал алгоритмы
+        Чтобы потом можно было в случае чего пересчитать очки, если что пойдет не так
+   Если я закончил уровень и он ждет Act(1) а я могу задать act(0) - запретить
-   Нарисовать таймер в клиенте, отображающего время работы над алгоритмом
-   Сделать в браузере кнопочку скип и кнопочку start по аналрогии с классами что я сделал для запуска act(N)
+   Закончить это в клиенте, чтобы не Act(0) act(1) отправлять а message('StartNextLevel') message('SkipThisLevel')
+       return new Strings("StartNextLevel");
+   Дописать тестов в реализацию Алексея